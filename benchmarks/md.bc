; ModuleID = 'p.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.LoopExecTime = type { double, double }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.timespec = type { i64, i64 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }

@data = common global [1000 x %struct.LoopExecTime] zeroinitializer, align 16
@copyCount = common global i64 0, align 8
@.str = private unnamed_addr constant [19 x i8] c"loop_exec_time.txt\00", align 1
@.str1 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str2 = private unnamed_addr constant [17 x i8] c"%lu, %lu, %.9lf\0A\00", align 1
@.str3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str14 = private unnamed_addr constant [4 x i8] c"MD\0A\00", align 1
@.str25 = private unnamed_addr constant [13 x i8] c"  C version\0A\00", align 1
@.str36 = private unnamed_addr constant [33 x i8] c"  A molecular dynamics program.\0A\00", align 1
@.str4 = private unnamed_addr constant [36 x i8] c"  ND, the spatial dimension, is %d\0A\00", align 1
@.str5 = private unnamed_addr constant [56 x i8] c"  NP, the number of particles in the simulation, is %d\0A\00", align 1
@.str6 = private unnamed_addr constant [45 x i8] c"  STEP_NUM, the number of time steps, is %d\0A\00", align 1
@.str7 = private unnamed_addr constant [41 x i8] c"  DT, the size of each time step, is %f\0A\00", align 1
@.str8 = private unnamed_addr constant [63 x i8] c"  At each step, we report the potential and kinetic energies.\0A\00", align 1
@.str9 = private unnamed_addr constant [51 x i8] c"  The sum of these energies should be a constant.\0A\00", align 1
@.str10 = private unnamed_addr constant [58 x i8] c"  As an accuracy check, we also print the relative error\0A\00", align 1
@.str11 = private unnamed_addr constant [24 x i8] c"  in the total energy.\0A\00", align 1
@.str12 = private unnamed_addr constant [60 x i8] c"      Step      Potential       Kinetic        (P+K-E0)/E0\0A\00", align 1
@.str13 = private unnamed_addr constant [70 x i8] c"                Energy P        Energy K       Relative Energy Error\0A\00", align 1
@.str147 = private unnamed_addr constant [25 x i8] c"  %8d  %14f  %14f  %14e\0A\00", align 1
@.str15 = private unnamed_addr constant [33 x i8] c"  Elapsed cpu time: %f seconds.\0A\00", align 1
@.str16 = private unnamed_addr constant [28 x i8] c"  Normal end of execution.\0A\00", align 1
@stderr = external global %struct._IO_FILE*
@.str17 = private unnamed_addr constant [33 x i8] c"R8MAT_UNIFORM_AB - Fatal error!\0A\00", align 1
@.str18 = private unnamed_addr constant [28 x i8] c"  Input value of SEED = 0.\0A\00", align 1
@timestamp.time_buffer = internal global [40 x i8] zeroinitializer, align 16
@.str19 = private unnamed_addr constant [21 x i8] c"%d %B %Y %I:%M:%S %p\00", align 1
@.str20 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1

; Function Attrs: nounwind uwtable
define double @getCurrentTime() #0 {
entry:
  %ts = alloca %struct.timespec, align 8
  %call = call i32 @clock_gettime(i32 1, %struct.timespec* %ts) #4
  %tv_sec = getelementptr inbounds %struct.timespec* %ts, i32 0, i32 0
  %0 = load i64* %tv_sec, align 8
  %conv = sitofp i64 %0 to double
  %tv_nsec = getelementptr inbounds %struct.timespec* %ts, i32 0, i32 1
  %1 = load i64* %tv_nsec, align 8
  %conv1 = sitofp i64 %1 to double
  %div = fdiv double %conv1, 1.000000e+09
  %add = fadd double %conv, %div
  ret double %add
}

; Function Attrs: nounwind
declare i32 @clock_gettime(i32, %struct.timespec*) #1

; Function Attrs: nounwind uwtable
define void @recordEntry(i64 %index) #0 {
entry:
  %index.addr = alloca i64, align 8
  store i64 %index, i64* %index.addr, align 8
  %0 = load i64* %index.addr, align 8
  %arrayidx = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %0
  %entryTime = getelementptr inbounds %struct.LoopExecTime* %arrayidx, i32 0, i32 0
  %1 = load double* %entryTime, align 8
  %cmp = fcmp ogt double %1, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call double @getCurrentTime()
  %2 = load i64* %index.addr, align 8
  %arrayidx1 = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %2
  %entryTime2 = getelementptr inbounds %struct.LoopExecTime* %arrayidx1, i32 0, i32 0
  store double %call, double* %entryTime2, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @recordExit(i64 %index) #0 {
entry:
  %index.addr = alloca i64, align 8
  store i64 %index, i64* %index.addr, align 8
  %0 = load i64* %index.addr, align 8
  %arrayidx = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %0
  %exitTime = getelementptr inbounds %struct.LoopExecTime* %arrayidx, i32 0, i32 1
  %1 = load double* %exitTime, align 8
  %cmp = fcmp ogt double %1, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call double @getCurrentTime()
  %2 = load i64* %index.addr, align 8
  %arrayidx1 = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %2
  %exitTime2 = getelementptr inbounds %struct.LoopExecTime* %arrayidx1, i32 0, i32 1
  store double %call, double* %exitTime2, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @setCopyCount(i64 %count) #0 {
entry:
  %count.addr = alloca i64, align 8
  store i64 %count, i64* %count.addr, align 8
  %0 = load i64* %count.addr, align 8
  store i64 %0, i64* @copyCount, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @printFinally(i64 %programID) #0 {
entry:
  %programID.addr = alloca i64, align 8
  %file = alloca %struct._IO_FILE*, align 8
  %i = alloca i32, align 4
  %id = alloca i64, align 8
  %duration = alloca double, align 8
  store i64 %programID, i64* %programID.addr, align 8
  %call = call %struct._IO_FILE* @fopen(i8* getelementptr inbounds ([19 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str1, i32 0, i32 0))
  store %struct._IO_FILE* %call, %struct._IO_FILE** %file, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 1000
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32* %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %idxprom
  %entryTime = getelementptr inbounds %struct.LoopExecTime* %arrayidx, i32 0, i32 0
  %2 = load double* %entryTime, align 8
  %cmp1 = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %3 = load i64* %programID.addr, align 8
  %mul = mul i64 %3, 100
  %4 = load i32* %i, align 4
  %conv = sext i32 %4 to i64
  %add = add i64 %mul, %conv
  store i64 %add, i64* %id, align 8
  %5 = load i32* %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %idxprom2
  %exitTime = getelementptr inbounds %struct.LoopExecTime* %arrayidx3, i32 0, i32 1
  %6 = load double* %exitTime, align 8
  %7 = load i32* %i, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr inbounds [1000 x %struct.LoopExecTime]* @data, i32 0, i64 %idxprom4
  %entryTime6 = getelementptr inbounds %struct.LoopExecTime* %arrayidx5, i32 0, i32 0
  %8 = load double* %entryTime6, align 8
  %sub = fsub double %6, %8
  store double %sub, double* %duration, align 8
  %9 = load %struct._IO_FILE** %file, align 8
  %10 = load i64* %id, align 8
  %11 = load i64* @copyCount, align 8
  %12 = load double* %duration, align 8
  %call7 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %9, i8* getelementptr inbounds ([17 x i8]* @.str2, i32 0, i32 0), i64 %10, i64 %11, double %12)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32* %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load %struct._IO_FILE** %file, align 8
  %call8 = call i32 @fclose(%struct._IO_FILE* %14)
  ret void
}

declare %struct._IO_FILE* @fopen(i8*, i8*) #2

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...) #2

declare i32 @fclose(%struct._IO_FILE*) #2

; Function Attrs: nounwind uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %acc = alloca double*, align 8
  %ctime = alloca double, align 8
  %dt = alloca double, align 8
  %e0 = alloca double, align 8
  %force = alloca double*, align 8
  %i = alloca i32, align 4
  %id = alloca i32, align 4
  %kinetic = alloca double, align 8
  %mass = alloca double, align 8
  %nd = alloca i32, align 4
  %np = alloca i32, align 4
  %pos = alloca double*, align 8
  %potential = alloca double, align 8
  %step = alloca i32, align 4
  %step_num = alloca i32, align 4
  %step_print = alloca i32, align 4
  %step_print_index = alloca i32, align 4
  %step_print_num = alloca i32, align 4
  %vel = alloca double*, align 8
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store double 1.000000e+00, double* %mass, align 8
  call void @timestamp()
  %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %call1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str14, i32 0, i32 0))
  %call2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([13 x i8]* @.str25, i32 0, i32 0))
  %call3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([33 x i8]* @.str36, i32 0, i32 0))
  store i32 2, i32* %nd, align 4
  store i32 500, i32* %np, align 4
  store i32 500, i32* %step_num, align 4
  store double 1.000000e-01, double* %dt, align 8
  %call4 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %0 = load i32* %nd, align 4
  %call5 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([36 x i8]* @.str4, i32 0, i32 0), i32 %0)
  %1 = load i32* %np, align 4
  %call6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([56 x i8]* @.str5, i32 0, i32 0), i32 %1)
  %2 = load i32* %step_num, align 4
  %call7 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([45 x i8]* @.str6, i32 0, i32 0), i32 %2)
  %3 = load double* %dt, align 8
  %call8 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([41 x i8]* @.str7, i32 0, i32 0), double %3)
  %4 = load i32* %nd, align 4
  %5 = load i32* %np, align 4
  %mul = mul nsw i32 %4, %5
  %conv = sext i32 %mul to i64
  %mul9 = mul i64 %conv, 8
  %call10 = call noalias i8* @malloc(i64 %mul9) #4
  %6 = bitcast i8* %call10 to double*
  store double* %6, double** %acc, align 8
  %7 = load i32* %nd, align 4
  %8 = load i32* %np, align 4
  %mul11 = mul nsw i32 %7, %8
  %conv12 = sext i32 %mul11 to i64
  %mul13 = mul i64 %conv12, 8
  %call14 = call noalias i8* @malloc(i64 %mul13) #4
  %9 = bitcast i8* %call14 to double*
  store double* %9, double** %force, align 8
  %10 = load i32* %nd, align 4
  %11 = load i32* %np, align 4
  %mul15 = mul nsw i32 %10, %11
  %conv16 = sext i32 %mul15 to i64
  %mul17 = mul i64 %conv16, 8
  %call18 = call noalias i8* @malloc(i64 %mul17) #4
  %12 = bitcast i8* %call18 to double*
  store double* %12, double** %pos, align 8
  %13 = load i32* %nd, align 4
  %14 = load i32* %np, align 4
  %mul19 = mul nsw i32 %13, %14
  %conv20 = sext i32 %mul19 to i64
  %mul21 = mul i64 %conv20, 8
  %call22 = call noalias i8* @malloc(i64 %mul21) #4
  %15 = bitcast i8* %call22 to double*
  store double* %15, double** %vel, align 8
  %call23 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %call24 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([63 x i8]* @.str8, i32 0, i32 0))
  %call25 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([51 x i8]* @.str9, i32 0, i32 0))
  %call26 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([58 x i8]* @.str10, i32 0, i32 0))
  %call27 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([24 x i8]* @.str11, i32 0, i32 0))
  %call28 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %call29 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([60 x i8]* @.str12, i32 0, i32 0))
  %call30 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([70 x i8]* @.str13, i32 0, i32 0))
  %call31 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  store i32 0, i32* %step_print, align 4
  store i32 0, i32* %step_print_index, align 4
  store i32 10, i32* %step_print_num, align 4
  %call32 = call double @cpu_time()
  store double %call32, double* %ctime, align 8
  store i32 0, i32* %step, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %16 = load i32* %step, align 4
  %17 = load i32* %step_num, align 4
  %cmp = icmp sle i32 %16, %17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load i32* %step, align 4
  %cmp34 = icmp eq i32 %18, 0
  br i1 %cmp34, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %19 = load i32* %np, align 4
  %20 = load i32* %nd, align 4
  %21 = load double** %pos, align 8
  %22 = load double** %vel, align 8
  %23 = load double** %acc, align 8
  call void @initialize(i32 %19, i32 %20, double* %21, double* %22, double* %23)
  br label %if.end

if.else:                                          ; preds = %for.body
  %24 = load i32* %np, align 4
  %25 = load i32* %nd, align 4
  %26 = load double** %pos, align 8
  %27 = load double** %vel, align 8
  %28 = load double** %force, align 8
  %29 = load double** %acc, align 8
  %30 = load double* %mass, align 8
  %31 = load double* %dt, align 8
  call void @update(i32 %24, i32 %25, double* %26, double* %27, double* %28, double* %29, double %30, double %31)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %32 = load i32* %np, align 4
  %33 = load i32* %nd, align 4
  %34 = load double** %pos, align 8
  %35 = load double** %vel, align 8
  %36 = load double* %mass, align 8
  %37 = load double** %force, align 8
  call void @compute(i32 %32, i32 %33, double* %34, double* %35, double %36, double* %37, double* %potential, double* %kinetic)
  %38 = load i32* %step, align 4
  %cmp36 = icmp eq i32 %38, 0
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end
  %39 = load double* %potential, align 8
  %40 = load double* %kinetic, align 8
  %add = fadd double %39, %40
  store double %add, double* %e0, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end
  %41 = load i32* %step, align 4
  %42 = load i32* %step_print, align 4
  %cmp40 = icmp eq i32 %41, %42
  br i1 %cmp40, label %if.then42, label %if.end48

if.then42:                                        ; preds = %if.end39
  %43 = load i32* %step, align 4
  %44 = load double* %potential, align 8
  %45 = load double* %kinetic, align 8
  %46 = load double* %potential, align 8
  %47 = load double* %kinetic, align 8
  %add43 = fadd double %46, %47
  %48 = load double* %e0, align 8
  %sub = fsub double %add43, %48
  %49 = load double* %e0, align 8
  %div = fdiv double %sub, %49
  %call44 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([25 x i8]* @.str147, i32 0, i32 0), i32 %43, double %44, double %45, double %div)
  %50 = load i32* %step_print_index, align 4
  %add45 = add nsw i32 %50, 1
  store i32 %add45, i32* %step_print_index, align 4
  %51 = load i32* %step_print_index, align 4
  %52 = load i32* %step_num, align 4
  %mul46 = mul nsw i32 %51, %52
  %53 = load i32* %step_print_num, align 4
  %div47 = sdiv i32 %mul46, %53
  store i32 %div47, i32* %step_print, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then42, %if.end39
  br label %for.inc

for.inc:                                          ; preds = %if.end48
  %54 = load i32* %step, align 4
  %inc = add nsw i32 %54, 1
  store i32 %inc, i32* %step, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call49 = call double @cpu_time()
  %55 = load double* %ctime, align 8
  %sub50 = fsub double %call49, %55
  store double %sub50, double* %ctime, align 8
  %call51 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %56 = load double* %ctime, align 8
  %call52 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([33 x i8]* @.str15, i32 0, i32 0), double %56)
  %57 = load double** %acc, align 8
  %58 = bitcast double* %57 to i8*
  call void @free(i8* %58) #4
  %59 = load double** %force, align 8
  %60 = bitcast double* %59 to i8*
  call void @free(i8* %60) #4
  %61 = load double** %pos, align 8
  %62 = bitcast double* %61 to i8*
  call void @free(i8* %62) #4
  %63 = load double** %vel, align 8
  %64 = bitcast double* %63 to i8*
  call void @free(i8* %64) #4
  %call53 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %call54 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str14, i32 0, i32 0))
  %call55 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([28 x i8]* @.str16, i32 0, i32 0))
  %call56 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  call void @timestamp()
  ret i32 0
}

declare i32 @printf(i8*, ...) #2

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) #1

; Function Attrs: nounwind uwtable
define void @initialize(i32 %np, i32 %nd, double* %pos, double* %vel, double* %acc) #0 {
entry:
  %np.addr = alloca i32, align 4
  %nd.addr = alloca i32, align 4
  %pos.addr = alloca double*, align 8
  %vel.addr = alloca double*, align 8
  %acc.addr = alloca double*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %seed = alloca i32, align 4
  store i32 %np, i32* %np.addr, align 4
  store i32 %nd, i32* %nd.addr, align 4
  store double* %pos, double** %pos.addr, align 8
  store double* %vel, double** %vel.addr, align 8
  store double* %acc, double** %acc.addr, align 8
  store i32 123456789, i32* %seed, align 4
  %0 = load i32* %nd.addr, align 4
  %1 = load i32* %np.addr, align 4
  %2 = load double** %pos.addr, align 8
  call void @r8mat_uniform_ab(i32 %0, i32 %1, double 0.000000e+00, double 1.000000e+01, i32* %seed, double* %2)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %3 = load i32* %j, align 4
  %4 = load i32* %np.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %5 = load i32* %i, align 4
  %6 = load i32* %nd.addr, align 4
  %cmp2 = icmp slt i32 %5, %6
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load i32* %i, align 4
  %8 = load i32* %j, align 4
  %9 = load i32* %nd.addr, align 4
  %mul = mul nsw i32 %8, %9
  %add = add nsw i32 %7, %mul
  %idxprom = sext i32 %add to i64
  %10 = load double** %vel.addr, align 8
  %arrayidx = getelementptr inbounds double* %10, i64 %idxprom
  store double 0.000000e+00, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %11 = load i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32* %j, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %j, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc20, %for.end6
  %13 = load i32* %j, align 4
  %14 = load i32* %np.addr, align 4
  %cmp8 = icmp slt i32 %13, %14
  br i1 %cmp8, label %for.body9, label %for.end22

for.body9:                                        ; preds = %for.cond7
  store i32 0, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc17, %for.body9
  %15 = load i32* %i, align 4
  %16 = load i32* %nd.addr, align 4
  %cmp11 = icmp slt i32 %15, %16
  br i1 %cmp11, label %for.body12, label %for.end19

for.body12:                                       ; preds = %for.cond10
  %17 = load i32* %i, align 4
  %18 = load i32* %j, align 4
  %19 = load i32* %nd.addr, align 4
  %mul13 = mul nsw i32 %18, %19
  %add14 = add nsw i32 %17, %mul13
  %idxprom15 = sext i32 %add14 to i64
  %20 = load double** %acc.addr, align 8
  %arrayidx16 = getelementptr inbounds double* %20, i64 %idxprom15
  store double 0.000000e+00, double* %arrayidx16, align 8
  br label %for.inc17

for.inc17:                                        ; preds = %for.body12
  %21 = load i32* %i, align 4
  %inc18 = add nsw i32 %21, 1
  store i32 %inc18, i32* %i, align 4
  br label %for.cond10

for.end19:                                        ; preds = %for.cond10
  br label %for.inc20

for.inc20:                                        ; preds = %for.end19
  %22 = load i32* %j, align 4
  %inc21 = add nsw i32 %22, 1
  store i32 %inc21, i32* %j, align 4
  br label %for.cond7

for.end22:                                        ; preds = %for.cond7
  ret void
}

; Function Attrs: nounwind uwtable
define void @update(i32 %np, i32 %nd, double* %pos, double* %vel, double* %f, double* %acc, double %mass, double %dt) #0 {
entry:
  %np.addr = alloca i32, align 4
  %nd.addr = alloca i32, align 4
  %pos.addr = alloca double*, align 8
  %vel.addr = alloca double*, align 8
  %f.addr = alloca double*, align 8
  %acc.addr = alloca double*, align 8
  %mass.addr = alloca double, align 8
  %dt.addr = alloca double, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %rmass = alloca double, align 8
  store i32 %np, i32* %np.addr, align 4
  store i32 %nd, i32* %nd.addr, align 4
  store double* %pos, double** %pos.addr, align 8
  store double* %vel, double** %vel.addr, align 8
  store double* %f, double** %f.addr, align 8
  store double* %acc, double** %acc.addr, align 8
  store double %mass, double* %mass.addr, align 8
  store double %dt, double* %dt.addr, align 8
  %0 = load double* %mass.addr, align 8
  %div = fdiv double 1.000000e+00, %0
  store double %div, double* %rmass, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc52, %entry
  %1 = load i32* %j, align 4
  %2 = load i32* %np.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end54

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32* %i, align 4
  %4 = load i32* %nd.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %5 = load i32* %i, align 4
  %6 = load i32* %j, align 4
  %7 = load i32* %nd.addr, align 4
  %mul = mul nsw i32 %6, %7
  %add = add nsw i32 %5, %mul
  %idxprom = sext i32 %add to i64
  %8 = load double** %pos.addr, align 8
  %arrayidx = getelementptr inbounds double* %8, i64 %idxprom
  %9 = load double* %arrayidx, align 8
  %10 = load i32* %i, align 4
  %11 = load i32* %j, align 4
  %12 = load i32* %nd.addr, align 4
  %mul4 = mul nsw i32 %11, %12
  %add5 = add nsw i32 %10, %mul4
  %idxprom6 = sext i32 %add5 to i64
  %13 = load double** %vel.addr, align 8
  %arrayidx7 = getelementptr inbounds double* %13, i64 %idxprom6
  %14 = load double* %arrayidx7, align 8
  %15 = load double* %dt.addr, align 8
  %mul8 = fmul double %14, %15
  %add9 = fadd double %9, %mul8
  %16 = load i32* %i, align 4
  %17 = load i32* %j, align 4
  %18 = load i32* %nd.addr, align 4
  %mul10 = mul nsw i32 %17, %18
  %add11 = add nsw i32 %16, %mul10
  %idxprom12 = sext i32 %add11 to i64
  %19 = load double** %acc.addr, align 8
  %arrayidx13 = getelementptr inbounds double* %19, i64 %idxprom12
  %20 = load double* %arrayidx13, align 8
  %mul14 = fmul double 5.000000e-01, %20
  %21 = load double* %dt.addr, align 8
  %mul15 = fmul double %mul14, %21
  %22 = load double* %dt.addr, align 8
  %mul16 = fmul double %mul15, %22
  %add17 = fadd double %add9, %mul16
  %23 = load i32* %i, align 4
  %24 = load i32* %j, align 4
  %25 = load i32* %nd.addr, align 4
  %mul18 = mul nsw i32 %24, %25
  %add19 = add nsw i32 %23, %mul18
  %idxprom20 = sext i32 %add19 to i64
  %26 = load double** %pos.addr, align 8
  %arrayidx21 = getelementptr inbounds double* %26, i64 %idxprom20
  store double %add17, double* %arrayidx21, align 8
  %27 = load i32* %i, align 4
  %28 = load i32* %j, align 4
  %29 = load i32* %nd.addr, align 4
  %mul22 = mul nsw i32 %28, %29
  %add23 = add nsw i32 %27, %mul22
  %idxprom24 = sext i32 %add23 to i64
  %30 = load double** %vel.addr, align 8
  %arrayidx25 = getelementptr inbounds double* %30, i64 %idxprom24
  %31 = load double* %arrayidx25, align 8
  %32 = load double* %dt.addr, align 8
  %mul26 = fmul double 5.000000e-01, %32
  %33 = load i32* %i, align 4
  %34 = load i32* %j, align 4
  %35 = load i32* %nd.addr, align 4
  %mul27 = mul nsw i32 %34, %35
  %add28 = add nsw i32 %33, %mul27
  %idxprom29 = sext i32 %add28 to i64
  %36 = load double** %f.addr, align 8
  %arrayidx30 = getelementptr inbounds double* %36, i64 %idxprom29
  %37 = load double* %arrayidx30, align 8
  %38 = load double* %rmass, align 8
  %mul31 = fmul double %37, %38
  %39 = load i32* %i, align 4
  %40 = load i32* %j, align 4
  %41 = load i32* %nd.addr, align 4
  %mul32 = mul nsw i32 %40, %41
  %add33 = add nsw i32 %39, %mul32
  %idxprom34 = sext i32 %add33 to i64
  %42 = load double** %acc.addr, align 8
  %arrayidx35 = getelementptr inbounds double* %42, i64 %idxprom34
  %43 = load double* %arrayidx35, align 8
  %add36 = fadd double %mul31, %43
  %mul37 = fmul double %mul26, %add36
  %add38 = fadd double %31, %mul37
  %44 = load i32* %i, align 4
  %45 = load i32* %j, align 4
  %46 = load i32* %nd.addr, align 4
  %mul39 = mul nsw i32 %45, %46
  %add40 = add nsw i32 %44, %mul39
  %idxprom41 = sext i32 %add40 to i64
  %47 = load double** %vel.addr, align 8
  %arrayidx42 = getelementptr inbounds double* %47, i64 %idxprom41
  store double %add38, double* %arrayidx42, align 8
  %48 = load i32* %i, align 4
  %49 = load i32* %j, align 4
  %50 = load i32* %nd.addr, align 4
  %mul43 = mul nsw i32 %49, %50
  %add44 = add nsw i32 %48, %mul43
  %idxprom45 = sext i32 %add44 to i64
  %51 = load double** %f.addr, align 8
  %arrayidx46 = getelementptr inbounds double* %51, i64 %idxprom45
  %52 = load double* %arrayidx46, align 8
  %53 = load double* %rmass, align 8
  %mul47 = fmul double %52, %53
  %54 = load i32* %i, align 4
  %55 = load i32* %j, align 4
  %56 = load i32* %nd.addr, align 4
  %mul48 = mul nsw i32 %55, %56
  %add49 = add nsw i32 %54, %mul48
  %idxprom50 = sext i32 %add49 to i64
  %57 = load double** %acc.addr, align 8
  %arrayidx51 = getelementptr inbounds double* %57, i64 %idxprom50
  store double %mul47, double* %arrayidx51, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %58 = load i32* %i, align 4
  %inc = add nsw i32 %58, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc52

for.inc52:                                        ; preds = %for.end
  %59 = load i32* %j, align 4
  %inc53 = add nsw i32 %59, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond

for.end54:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @compute(i32 %np, i32 %nd, double* %pos, double* %vel, double %mass, double* %f, double* %pot, double* %kin) #0 {
entry:
  %np.addr = alloca i32, align 4
  %nd.addr = alloca i32, align 4
  %pos.addr = alloca double*, align 8
  %vel.addr = alloca double*, align 8
  %mass.addr = alloca double, align 8
  %f.addr = alloca double*, align 8
  %pot.addr = alloca double*, align 8
  %kin.addr = alloca double*, align 8
  %d = alloca double, align 8
  %d2 = alloca double, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %ke = alloca double, align 8
  %pe = alloca double, align 8
  %PI2 = alloca double, align 8
  %rij = alloca [3 x double], align 16
  store i32 %np, i32* %np.addr, align 4
  store i32 %nd, i32* %nd.addr, align 4
  store double* %pos, double** %pos.addr, align 8
  store double* %vel, double** %vel.addr, align 8
  store double %mass, double* %mass.addr, align 8
  store double* %f, double** %f.addr, align 8
  store double* %pot, double** %pot.addr, align 8
  store double* %kin, double** %kin.addr, align 8
  store double 0x3FF921FB54442D18, double* %PI2, align 8
  store double 0.000000e+00, double* %pe, align 8
  store double 0.000000e+00, double* %ke, align 8
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc57, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %np.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end59

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32* %i, align 4
  %3 = load i32* %nd.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32* %i, align 4
  %5 = load i32* %k, align 4
  %6 = load i32* %nd.addr, align 4
  %mul = mul nsw i32 %5, %6
  %add = add nsw i32 %4, %mul
  %idxprom = sext i32 %add to i64
  %7 = load double** %f.addr, align 8
  %arrayidx = getelementptr inbounds double* %7, i64 %idxprom
  store double 0.000000e+00, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  store i32 0, i32* %j, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc38, %for.end
  %9 = load i32* %j, align 4
  %10 = load i32* %np.addr, align 4
  %cmp5 = icmp slt i32 %9, %10
  br i1 %cmp5, label %for.body6, label %for.end40

for.body6:                                        ; preds = %for.cond4
  %11 = load i32* %k, align 4
  %12 = load i32* %j, align 4
  %cmp7 = icmp ne i32 %11, %12
  br i1 %cmp7, label %if.then, label %if.end37

if.then:                                          ; preds = %for.body6
  %13 = load i32* %nd.addr, align 4
  %14 = load double** %pos.addr, align 8
  %15 = load i32* %k, align 4
  %16 = load i32* %nd.addr, align 4
  %mul8 = mul nsw i32 %15, %16
  %idx.ext = sext i32 %mul8 to i64
  %add.ptr = getelementptr inbounds double* %14, i64 %idx.ext
  %17 = load double** %pos.addr, align 8
  %18 = load i32* %j, align 4
  %19 = load i32* %nd.addr, align 4
  %mul9 = mul nsw i32 %18, %19
  %idx.ext10 = sext i32 %mul9 to i64
  %add.ptr11 = getelementptr inbounds double* %17, i64 %idx.ext10
  %arraydecay = getelementptr inbounds [3 x double]* %rij, i32 0, i32 0
  %call = call double @dist(i32 %13, double* %add.ptr, double* %add.ptr11, double* %arraydecay)
  store double %call, double* %d, align 8
  %20 = load double* %d, align 8
  %21 = load double* %PI2, align 8
  %cmp12 = fcmp olt double %20, %21
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.then
  %22 = load double* %d, align 8
  store double %22, double* %d2, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %23 = load double* %PI2, align 8
  store double %23, double* %d2, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then13
  %24 = load double* %pe, align 8
  %25 = load double* %d2, align 8
  %call14 = call double @sin(double %25) #4
  %call15 = call double @pow(double %call14, double 2.000000e+00) #4
  %mul16 = fmul double 5.000000e-01, %call15
  %add17 = fadd double %24, %mul16
  store double %add17, double* %pe, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc34, %if.end
  %26 = load i32* %i, align 4
  %27 = load i32* %nd.addr, align 4
  %cmp19 = icmp slt i32 %26, %27
  br i1 %cmp19, label %for.body20, label %for.end36

for.body20:                                       ; preds = %for.cond18
  %28 = load i32* %i, align 4
  %29 = load i32* %k, align 4
  %30 = load i32* %nd.addr, align 4
  %mul21 = mul nsw i32 %29, %30
  %add22 = add nsw i32 %28, %mul21
  %idxprom23 = sext i32 %add22 to i64
  %31 = load double** %f.addr, align 8
  %arrayidx24 = getelementptr inbounds double* %31, i64 %idxprom23
  %32 = load double* %arrayidx24, align 8
  %33 = load i32* %i, align 4
  %idxprom25 = sext i32 %33 to i64
  %arrayidx26 = getelementptr inbounds [3 x double]* %rij, i32 0, i64 %idxprom25
  %34 = load double* %arrayidx26, align 8
  %35 = load double* %d2, align 8
  %mul27 = fmul double 2.000000e+00, %35
  %call28 = call double @sin(double %mul27) #4
  %mul29 = fmul double %34, %call28
  %36 = load double* %d, align 8
  %div = fdiv double %mul29, %36
  %sub = fsub double %32, %div
  %37 = load i32* %i, align 4
  %38 = load i32* %k, align 4
  %39 = load i32* %nd.addr, align 4
  %mul30 = mul nsw i32 %38, %39
  %add31 = add nsw i32 %37, %mul30
  %idxprom32 = sext i32 %add31 to i64
  %40 = load double** %f.addr, align 8
  %arrayidx33 = getelementptr inbounds double* %40, i64 %idxprom32
  store double %sub, double* %arrayidx33, align 8
  br label %for.inc34

for.inc34:                                        ; preds = %for.body20
  %41 = load i32* %i, align 4
  %inc35 = add nsw i32 %41, 1
  store i32 %inc35, i32* %i, align 4
  br label %for.cond18

for.end36:                                        ; preds = %for.cond18
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.body6
  br label %for.inc38

for.inc38:                                        ; preds = %if.end37
  %42 = load i32* %j, align 4
  %inc39 = add nsw i32 %42, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond4

for.end40:                                        ; preds = %for.cond4
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc54, %for.end40
  %43 = load i32* %i, align 4
  %44 = load i32* %nd.addr, align 4
  %cmp42 = icmp slt i32 %43, %44
  br i1 %cmp42, label %for.body43, label %for.end56

for.body43:                                       ; preds = %for.cond41
  %45 = load double* %ke, align 8
  %46 = load i32* %i, align 4
  %47 = load i32* %k, align 4
  %48 = load i32* %nd.addr, align 4
  %mul44 = mul nsw i32 %47, %48
  %add45 = add nsw i32 %46, %mul44
  %idxprom46 = sext i32 %add45 to i64
  %49 = load double** %vel.addr, align 8
  %arrayidx47 = getelementptr inbounds double* %49, i64 %idxprom46
  %50 = load double* %arrayidx47, align 8
  %51 = load i32* %i, align 4
  %52 = load i32* %k, align 4
  %53 = load i32* %nd.addr, align 4
  %mul48 = mul nsw i32 %52, %53
  %add49 = add nsw i32 %51, %mul48
  %idxprom50 = sext i32 %add49 to i64
  %54 = load double** %vel.addr, align 8
  %arrayidx51 = getelementptr inbounds double* %54, i64 %idxprom50
  %55 = load double* %arrayidx51, align 8
  %mul52 = fmul double %50, %55
  %add53 = fadd double %45, %mul52
  store double %add53, double* %ke, align 8
  br label %for.inc54

for.inc54:                                        ; preds = %for.body43
  %56 = load i32* %i, align 4
  %inc55 = add nsw i32 %56, 1
  store i32 %inc55, i32* %i, align 4
  br label %for.cond41

for.end56:                                        ; preds = %for.cond41
  br label %for.inc57

for.inc57:                                        ; preds = %for.end56
  %57 = load i32* %k, align 4
  %inc58 = add nsw i32 %57, 1
  store i32 %inc58, i32* %k, align 4
  br label %for.cond

for.end59:                                        ; preds = %for.cond
  %58 = load double* %ke, align 8
  %mul60 = fmul double %58, 5.000000e-01
  %59 = load double* %mass.addr, align 8
  %mul61 = fmul double %mul60, %59
  store double %mul61, double* %ke, align 8
  %60 = load double* %pe, align 8
  %61 = load double** %pot.addr, align 8
  store double %60, double* %61, align 8
  %62 = load double* %ke, align 8
  %63 = load double** %kin.addr, align 8
  store double %62, double* %63, align 8
  ret void
}

; Function Attrs: nounwind
declare void @free(i8*) #1

; Function Attrs: nounwind uwtable
define double @dist(i32 %nd, double* %r1, double* %r2, double* %dr) #0 {
entry:
  %nd.addr = alloca i32, align 4
  %r1.addr = alloca double*, align 8
  %r2.addr = alloca double*, align 8
  %dr.addr = alloca double*, align 8
  %d = alloca double, align 8
  %i = alloca i32, align 4
  store i32 %nd, i32* %nd.addr, align 4
  store double* %r1, double** %r1.addr, align 8
  store double* %r2, double** %r2.addr, align 8
  store double* %dr, double** %dr.addr, align 8
  store double 0.000000e+00, double* %d, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load i32* %nd.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load double** %r1.addr, align 8
  %arrayidx = getelementptr inbounds double* %3, i64 %idxprom
  %4 = load double* %arrayidx, align 8
  %5 = load i32* %i, align 4
  %idxprom1 = sext i32 %5 to i64
  %6 = load double** %r2.addr, align 8
  %arrayidx2 = getelementptr inbounds double* %6, i64 %idxprom1
  %7 = load double* %arrayidx2, align 8
  %sub = fsub double %4, %7
  %8 = load i32* %i, align 4
  %idxprom3 = sext i32 %8 to i64
  %9 = load double** %dr.addr, align 8
  %arrayidx4 = getelementptr inbounds double* %9, i64 %idxprom3
  store double %sub, double* %arrayidx4, align 8
  %10 = load double* %d, align 8
  %11 = load i32* %i, align 4
  %idxprom5 = sext i32 %11 to i64
  %12 = load double** %dr.addr, align 8
  %arrayidx6 = getelementptr inbounds double* %12, i64 %idxprom5
  %13 = load double* %arrayidx6, align 8
  %14 = load i32* %i, align 4
  %idxprom7 = sext i32 %14 to i64
  %15 = load double** %dr.addr, align 8
  %arrayidx8 = getelementptr inbounds double* %15, i64 %idxprom7
  %16 = load double* %arrayidx8, align 8
  %mul = fmul double %13, %16
  %add = fadd double %10, %mul
  store double %add, double* %d, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load double* %d, align 8
  %call = call double @sqrt(double %18) #4
  store double %call, double* %d, align 8
  %19 = load double* %d, align 8
  ret double %19
}

; Function Attrs: nounwind
declare double @pow(double, double) #1

; Function Attrs: nounwind
declare double @sin(double) #1

; Function Attrs: nounwind uwtable
define double @cpu_time() #0 {
entry:
  %value = alloca double, align 8
  %call = call i64 @clock() #4
  %conv = sitofp i64 %call to double
  %div = fdiv double %conv, 1.000000e+06
  store double %div, double* %value, align 8
  %0 = load double* %value, align 8
  ret double %0
}

; Function Attrs: nounwind
declare i64 @clock() #1

; Function Attrs: nounwind
declare double @sqrt(double) #1

; Function Attrs: nounwind uwtable
define void @r8mat_uniform_ab(i32 %m, i32 %n, double %a, double %b, i32* %seed, double* %r) #0 {
entry:
  %m.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %a.addr = alloca double, align 8
  %b.addr = alloca double, align 8
  %seed.addr = alloca i32*, align 8
  %r.addr = alloca double*, align 8
  %i = alloca i32, align 4
  %i4_huge = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  store i32 %m, i32* %m.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  store double %a, double* %a.addr, align 8
  store double %b, double* %b.addr, align 8
  store i32* %seed, i32** %seed.addr, align 8
  store double* %r, double** %r.addr, align 8
  store i32 2147483647, i32* %i4_huge, align 4
  %0 = load i32** %seed.addr, align 8
  %1 = load i32* %0, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct._IO_FILE** @stderr, align 8
  %call = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  %3 = load %struct._IO_FILE** @stderr, align 8
  %call1 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([33 x i8]* @.str17, i32 0, i32 0))
  %4 = load %struct._IO_FILE** @stderr, align 8
  %call2 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %4, i8* getelementptr inbounds ([28 x i8]* @.str18, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %if.end
  %5 = load i32* %j, align 4
  %6 = load i32* %n.addr, align 4
  %cmp3 = icmp slt i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body
  %7 = load i32* %i, align 4
  %8 = load i32* %m.addr, align 4
  %cmp5 = icmp slt i32 %7, %8
  br i1 %cmp5, label %for.body6, label %for.end

for.body6:                                        ; preds = %for.cond4
  %9 = load i32** %seed.addr, align 8
  %10 = load i32* %9, align 4
  %div = sdiv i32 %10, 127773
  store i32 %div, i32* %k, align 4
  %11 = load i32** %seed.addr, align 8
  %12 = load i32* %11, align 4
  %13 = load i32* %k, align 4
  %mul = mul nsw i32 %13, 127773
  %sub = sub nsw i32 %12, %mul
  %mul7 = mul nsw i32 16807, %sub
  %14 = load i32* %k, align 4
  %mul8 = mul nsw i32 %14, 2836
  %sub9 = sub nsw i32 %mul7, %mul8
  %15 = load i32** %seed.addr, align 8
  store i32 %sub9, i32* %15, align 4
  %16 = load i32** %seed.addr, align 8
  %17 = load i32* %16, align 4
  %cmp10 = icmp slt i32 %17, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body6
  %18 = load i32** %seed.addr, align 8
  %19 = load i32* %18, align 4
  %add = add nsw i32 %19, 2147483647
  %20 = load i32** %seed.addr, align 8
  store i32 %add, i32* %20, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %for.body6
  %21 = load double* %a.addr, align 8
  %22 = load double* %b.addr, align 8
  %23 = load double* %a.addr, align 8
  %sub13 = fsub double %22, %23
  %24 = load i32** %seed.addr, align 8
  %25 = load i32* %24, align 4
  %conv = sitofp i32 %25 to double
  %mul14 = fmul double %sub13, %conv
  %mul15 = fmul double %mul14, 0x3E000000001C5F68
  %add16 = fadd double %21, %mul15
  %26 = load i32* %i, align 4
  %27 = load i32* %j, align 4
  %28 = load i32* %m.addr, align 4
  %mul17 = mul nsw i32 %27, %28
  %add18 = add nsw i32 %26, %mul17
  %idxprom = sext i32 %add18 to i64
  %29 = load double** %r.addr, align 8
  %arrayidx = getelementptr inbounds double* %29, i64 %idxprom
  store double %add16, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %30 = load i32* %i, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond4

for.end:                                          ; preds = %for.cond4
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %31 = load i32* %j, align 4
  %inc20 = add nsw i32 %31, 1
  store i32 %inc20, i32* %j, align 4
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noreturn nounwind
declare void @exit(i32) #3

; Function Attrs: nounwind uwtable
define void @timestamp() #0 {
entry:
  %tm = alloca %struct.tm*, align 8
  %len = alloca i64, align 8
  %now = alloca i64, align 8
  %call = call i64 @time(i64* null) #4
  store i64 %call, i64* %now, align 8
  %call1 = call %struct.tm* @localtime(i64* %now) #4
  store %struct.tm* %call1, %struct.tm** %tm, align 8
  %0 = load %struct.tm** %tm, align 8
  %call2 = call i64 @strftime(i8* getelementptr inbounds ([40 x i8]* @timestamp.time_buffer, i32 0, i32 0), i64 40, i8* getelementptr inbounds ([21 x i8]* @.str19, i32 0, i32 0), %struct.tm* %0) #4
  store i64 %call2, i64* %len, align 8
  %call3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str20, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8]* @timestamp.time_buffer, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind
declare i64 @time(i64*) #1

; Function Attrs: nounwind
declare %struct.tm* @localtime(i64*) #1

; Function Attrs: nounwind
declare i64 @strftime(i8*, i64, i8*, %struct.tm*) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { noreturn nounwind }
